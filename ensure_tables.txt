TODO:
- generated columns (virtual and materialized)
- partial indexes (postgres and sqlite only)
- indexes on expressions

NO SUPPORT FOR MULTICOLUMN UNIQUE CONSTRAINT. Use a multicolumn unique index instead. This is to make column diffing easier: each column carries its own self-contained set of constraints.

Does table exist? If not create it and return
Else do columns exist? If not create it and return
Else do the column stats match? If not call the resolver
- type
- notnull
- default (expr)
- primarykey
- unique
- identity/serial/autoincrement
- references (table, column)
- check (expr)
- onupdate (expr) # will always be unset for postgres or sqlite
- default (expr)
Do the table stats match?
- index (column(s), condition, index_type)

events:
- table creation
    - used for attaching triggers and stuff to a FTS table
- table already exists
- column creation
- column already exists
- column stats mismatch
- indices mismatch (can indices be identified by their contents?)

stuff the user can check manually for:
- some column exists but some column doesn't (for renaming columns)
- some table exists but some table doesn't (for renaming tables)

func(row *sq.Row) {
    x := row.String(X)
    y := row.String(Y)
    row.Process(func() error { res = append(res, x, y); return nil })
    row.Handle(func() error { res = append(res, x, y); return nil })
    row.Prepare(func() error { res = append(res, x, y); return nil })
    row.Transform(func() error { res = append(res, x, y); return nil })
    row.Work(func() error { res = append(res, x, y); return nil })
    row.Accumulate(func() error { res = append(res, x, y); return nil })
    row.Manage(func() error { res = append(res, x, y); return nil })
    row.Convert(func() error { res = append(res, x, y); return nil })
    row.Compute(func() error { res = append(res, x, y); return nil })
    row.Manipulate(func() error { res = append(res, x, y); return nil })
    row.Calculate(func() error { res = append(res, x, y); return nil })
}

CREATE TABLE address (
    address_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
    ,address TEXT NOT NULL
    ,address2 TEXT
    ,district TEXT NOT NULL
    ,city_id INT NOT NULL
    ,postal_code TEXT
    ,phone TEXT NOT NULL
    ,last_update TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

type ADDRESS struct {
    sq.TableInfo `ddl:"name=address schema=public create={ENGINE=InnoDB DEFAULT CHARSET=utf8}"`
    ADDRESS_ID sq.NumberField `sq:"type=INT unique identity notnull primarykey"`
    ADDRESS sq.StringField `sq:"notnull check={address <> ''}"`
    ADDRESS2 sq.StringField `sq:""`
    DISTRICT sq.StringField `sq:"notnull"`
    CITY_ID sq.StringField `sq:"references=students(student_id)"`
    POSTAL_CODE sq.StringField `sq:"notnull" index=btree,text_pattern_ops`
    LAST_UPDATE sq.TimeField `sq:"default='' notnull"`

    SPECIAL_FEATURES sq.ArrayField `sq:"type={TEXT[]} default={ARRAY []}"`
    FULLTEXT sq.StringField `sq:"type=TSVECTOR"`
    AMOUNT sq.NumberField `sq:"type=NUMERIC(5,2)"`
}

tables.go
table_constructors.go

unique
identity/serial/autoincrement
notnull
primarykey
references
check
type={UNSIGNED INT}
onupdate=NOW()
index
index=btree
index=gin
index=fulltext

use {} for string quoting instead of [] so that dumbasses that insist on using whitespace in their table and column names can use [] to quote them as usual (SQL Server syntax)

MySQL uses its own (non-deterministic) naming convention for anonymous constraints defined in CREATE TABLE:
- UNIQUE
- FOREIGN KEY
This means such constraints have to be identified by their contents, and not their name because their name is entirely non-deterministic.
OR RATHER: we never rely on MySQL to generate a name. We use Postgres' determnistic naming convention to define all constraint names, so that we may use them for identifying CHECK and INDEX constraints

unique may take multiple columns
indices may take multiple columns
indices may use a different indexing strategy
cross-column requirements means all constraints -must- also be declarable through methods
method declared constraints also make it possible to enforce database-specific constraints by calling the corresponding method based on the database dialect

because constraints -have- to be worked out in the same call to ensuretables (SQLite doesn't allow adding constraints after the table has been created), a Constraints() method must be declared on each table that has additional constraints to be carried out.

non-parametric constraints:
- primarykey
- unique
- identity/serial/autoincrement
- notnull
parametric constraints:
- references
- check
- indices

CHECK and INDEX DDL are identified by their name, because they cannot be identified by their contents. Only FOREIGN KEY DDL can be identified by its contents, because of how structured FOREIGN KEY DDL is.
Actually... INDEX DDLs are quite structured as well. Indices are identified by (table, column(s), index_type)

there are some operations that are possible to do but not safe to carry out at scale:
- changing type
- adding unique constraint
-
I think such operations should have an opt-in resolver i.e. use the resolver if it exists, else do the action.

SQLite does not support adding constraints to an existing table, which means it cannot add unique/notnull/foreignkey after the fact. This means EnsureTables will likely return an error, unless one defines a constraint resolver that adds a temp_column with the constraints, copies the data over from the column, drops the column then renames the temp_column to the column. All of this must be defined explicitly by the programmer of course, if they know they are using an sqlite database they must define such procedures manually.

No database trigger support is planned. If one needs triggers:
- before_insert/before_update, row_level triggers can be defined in the column mappers.
- after_insert/after_update, row_level triggers are not possible because the callback does not have access to the values that the database conjures up.
    - If one needs after_insert/after_update triggers, create the triggers manually on the database side.
- statement_level triggers are not possible.
    - If one needs statement_level triggers, they should define their own procedures to be called after each insert/update/delete/etc query. This is much more explicit and less prone to magic behavior rife in the database.
